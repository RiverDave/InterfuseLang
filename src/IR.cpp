#include "../include/IR.h"
#include <llvm-c/Target.h>
#include <llvm-c/TargetMachine.h>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/ExecutionEngine/MCJIT.h>
#include <llvm/ExecutionEngine/SectionMemoryManager.h>
#include <llvm/IR/Module.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Target/TargetOptions.h>
#include <llvm/TargetParser/Triple.h>
#include <unordered_map>

using namespace llvm;

// Entry point for code generation
void CodeGenContext::emitIR(NBlock &srcRoot) {
  std::cout << "Mixing Pour..." << std::endl;

  // Top level block
  std::vector<llvm::Type *> argTypes;
  llvm::FunctionType *ftype = llvm::FunctionType::get(
      Type::getVoidTy(*TheContext), llvm::ArrayRef(argTypes), false);

  globalFn = Function::Create(ftype, llvm::GlobalValue::InternalLinkage, "main",
                              TheModule.get());

  BasicBlock *bblock = BasicBlock::Create(*TheContext, "entry", globalFn, 0);
  pushBlock(bblock);

  // Recursively generate code for each node in the AST
  srcRoot.codeGen(*this);

  ReturnInst::Create(*TheContext, bblock);
  popBlock();

  globalFn->print(llvm::errs());
}

llvm::GenericValue CodeGenContext::runCode() {
  std::cout << "Running code...\n";

  std::string error;
  llvm::ExecutionEngine *ee =
      EngineBuilder(std::move(TheModule)).setErrorStr(&error).create();
  if (!ee) {
    std::cerr << "Failed to create ExecutionEngine: " << error << std::endl;
    throw std::runtime_error("Failed to create ExecutionEngine");
  }
  ee->finalizeObject();
  //
  std::vector<GenericValue> noargs;
  GenericValue v = ee->runFunction(globalFn, noargs);
  std::cout << "Code was run.\n";

  return v;
}

void CodeGenContext::setTarget() {
  LLVMInitializeNativeTarget();
  LLVMInitializeNativeAsmPrinter();
  // LLVMInitializeNativeAsmParser(); //FIXME: This wouldn't link for some
  // reason

  auto TargetTriple = LLVMGetDefaultTargetTriple();
  TheModule->setTargetTriple(TargetTriple);
}

// Helper
llvm::Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}

llvm::AllocaInst *CodeGenContext::insertMemOnFnBlock(llvm::Function *fn,
                                                     std::string &id,
                                                     llvm::Type *type) {
  if (Builder->GetInsertBlock() == nullptr && fn != nullptr) {
    std::cout << "FN has no insertBLock" << std::endl;
    // Insert at the beginning of the function
    Builder->SetInsertPoint(&fn->getEntryBlock());
  } else if (Builder->GetInsertBlock()->getParent() == nullptr) {
    std::cout << "FN has no parent" << std::endl;
    return nullptr;
  }

  fn = Builder->GetInsertBlock()->getParent();

  IRBuilder<> TmpB(&fn->getEntryBlock(), fn->getEntryBlock().begin());
  return TmpB.CreateAlloca(type, 0, id.c_str());
}

// CODE GEN STUFF:
llvm::Value *NBlock::codeGen(CodeGenContext &context) {
  Value *last = nullptr;

  std::for_each(statements.begin(), statements.end(),
                [&](NStatement *stmt) { last = stmt->codeGen(context); });

  return last;
}

llvm::Value *NDouble::codeGen(CodeGenContext &context) {
  std::cout << "Generating code for double: " << value << std::endl;
  // Communicates context with generated bytecode
  return llvm::ConstantFP::get(*context.TheContext, llvm::APFloat(this->value));
}

llvm::Value *NInteger::codeGen(CodeGenContext &context) {
  std::cout << "Generating code for Integer: " << value << std::endl;
  return llvm::ConstantInt::get(llvm::Type::getInt64Ty(*context.TheContext),
                                value, true);
}

llvm::Value *NExpressionStatement::codeGen(CodeGenContext &context) {
  return expression.codeGen(context);
}

// Variable expression
llvm::Value *NIdentifier::codeGen(CodeGenContext &context) {
  AllocaInst *V = context.blocks.top()->locals[name];

  if (!V) {
    LogErrorV("Local not found!");
    return nullptr;
  }

  // Load variable from the stack
  return context.Builder->CreateLoad(V->getAllocatedType(), V, name.c_str());
}

llvm::Type *NIdentifier::getType(CodeGenContext &context) const {
  // TODO: Complement types?

  std::unordered_map<std::string, llvm::Type *> typeMap{
      {"int", llvm::Type::getInt64Ty(*context.TheContext)},
      {"double", llvm::Type::getDoubleTy(*context.TheContext)},
      {"float", llvm::Type::getFloatTy(*context.TheContext)}
      //{"bool", llvm::Type::getInt64Ty(*context.TheContext)},
      //{"int", llvm::Type::getInt64Ty(*context.TheContext)},
  };

  auto it = typeMap.find(name);
  if (it == typeMap.end()) {
    // Throw Error: Unknown type
    return nullptr;
  }

  return it->second;
}

llvm::Value *NBinaryOperator::codeGen(CodeGenContext &context) {
  auto toktype = op.getType();

  switch (toktype) {
  case OPERATOR_PLUS:
    std::cout << "Creating addition :" << std::endl;
    return context.Builder->CreateAdd(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempadd");
  case OPERATOR_MINUS:
    std::cout << "Creating subtraction :" << std::endl;
    return context.Builder->CreateSub(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempsub");

  case OPERATOR_DIVIDE:
    std::cout << "Creating division :" << std::endl;
    return context.Builder->CreateSDiv(lhs.codeGen(context),
                                       rhs.codeGen(context), "tempdiv");

  case OPERATOR_MULTIPLY:
    std::cout << "Creating multiplication :" << std::endl;
    return context.Builder->CreateMul(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempmul");

  default:
    LogErrorV("Invalid binary op");
  }

  return nullptr;
}

llvm::Value *NVariableDeclaration::codeGen(CodeGenContext &context) {
  Function *theFunction = context.globalFn;

  // if(!assignmentExpr){
  //   //handle empty variable declaration
  // }

  AllocaInst *alloc = nullptr;


  //    auto locals = context.blocks.top()->locals;

  auto find = context.blocks.top()->locals.find(id->name);

  if (find == context.blocks.top()->locals.end()) {
    alloc = context.insertMemOnFnBlock(theFunction, id->name, type.getType(context));
    context.blocks.top()->locals[id->name] = alloc;
  } else {
    // Function redefinition detected, prevent allocation

    LogErrorV("Function redefinition detected\n");
    throw std::runtime_error("Redefinition detected");
  }

  // NOTE: the llvm docs mention about storing the old local bindings to be able
  // to use recursion(Might need to do that later).

  return context.Builder->CreateStore(assignmentExpr->codeGen(context), alloc);
}

llvm::Value *NAssignment::codeGen(CodeGenContext &context) {
  Value *value = rhs.codeGen(context);

  if (value == nullptr) {
    return nullptr;
  }

  // see variable existance
  Value *var = context.blocks.top()->locals[lhs.name];
  if (!var) {
    return LogErrorV("Unknown variable name");
  }

  // load variable
  return context.Builder->CreateStore(value, var);
}

llvm::Value *NUnaryOperator::codeGen(CodeGenContext &context) {
  return nullptr;
}

llvm::Value *NReturnStatement::codeGen(CodeGenContext &context) {
  return nullptr;
}

llvm::Value *NWhileStatement::codeGen(CodeGenContext &context) {
  return nullptr;
}

llvm::Value *NForStatement::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NFnDeclaration::codeGen(CodeGenContext &context) {
  return nullptr;
}

llvm::Value *NFnCall::codeGen(CodeGenContext &context) { return nullptr; }
llvm::Value *NString::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NIfStatement::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NElseStatement::codeGen(CodeGenContext &context) {
  return nullptr;
}
