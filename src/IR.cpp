#include "../include/IR.h"
#include <llvm-c/Target.h>
#include <llvm-c/TargetMachine.h>
#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/ExecutionEngine/MCJIT.h>
#include <llvm/ExecutionEngine/SectionMemoryManager.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Verifier.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Target/TargetOptions.h>
#include <llvm/TargetParser/Triple.h>
#include <unordered_map>

using namespace llvm;

// Entry point for code generation
void CodeGenContext::emitIR(NBlock &srcRoot) {
  std::cout << "Mixing Pour..." << std::endl;

  // Top level block
  std::vector<llvm::Type *> argTypes;
  llvm::FunctionType *ftype = llvm::FunctionType::get(
      Type::getVoidTy(*TheContext), llvm::ArrayRef(argTypes), false);

  globalFn = Function::Create(ftype, llvm::GlobalValue::InternalLinkage, "main",
                              TheModule.get());

  BasicBlock *bblock = BasicBlock::Create(*TheContext, "entry", globalFn, 0);
  pushBlock(bblock);

  // Recursively generate code for each node in the AST
  srcRoot.codeGen(*this);

  ReturnInst::Create(*TheContext, bblock);
  popBlock();

  globalFn->print(llvm::errs());
}

llvm::GenericValue CodeGenContext::runCode() {
  std::cout << "Running code...\n";

  std::string error;
  llvm::ExecutionEngine *ee =
      EngineBuilder(std::move(TheModule)).setErrorStr(&error).create();

  if (!ee) {
    std::string err = "Failed to create ExecutionEngine: ";
    LogErrorV(err.c_str());
    throw std::runtime_error(err);
  }

  try {
    if (ee->hasError()) {
      std::cerr << ee->getErrorMessage() << std::endl;

      std::string err = "Failed to create ExecutionEngine";
      LogErrorV(err.c_str());
      throw std::runtime_error(err);
    }
    // FIXME: Returning exception for some reason!! after calling function
    ee->finalizeObject();
  } catch (const std::exception &e) {
    if (e.what()) {
      std::cout << e.what() << std::endl;
      std::cout << ee->getErrorMessage() << std::endl;
    }
  }

  //
  std::vector<GenericValue> noargs;
  GenericValue v = ee->runFunction(globalFn, noargs);
  std::cout << "Code was run.\n";

  return v;
}

void CodeGenContext::setTarget() {
  // LLVMLinkInMCJIT();

  LLVMInitializeNativeTarget();
  LLVMInitializeNativeAsmPrinter();

  // LLVMInitializeNativeAsmParser(); //FIXME: This wouldn't link for some
  // reason

  auto TargetTriple = LLVMGetDefaultTargetTriple();
  TheModule->setTargetTriple(TargetTriple);
}

// Helper
llvm::Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}

llvm::AllocaInst *CodeGenContext::insertMemOnFnBlock(llvm::Function *fn,
                                                     std::string &id,
                                                     llvm::Type *type) {
  if (Builder->GetInsertBlock() == nullptr && fn != nullptr) {
    // std::cout << "FN has no insertBLock" << std::endl;
    // Insert at the beginning of the function
    Builder->SetInsertPoint(&fn->getEntryBlock());
  } else if (Builder->GetInsertBlock()->getParent() == nullptr) {
    std::cout << "FN has no parent" << std::endl;
    return nullptr;
  }

  fn = Builder->GetInsertBlock()->getParent();

  IRBuilder<> TmpB(&fn->getEntryBlock(), fn->getEntryBlock().begin());
  return TmpB.CreateAlloca(type, 0, id.c_str());
}

// CODE GEN STUFF:
llvm::Value *NBlock::codeGen(CodeGenContext &context) {
  Value *last = nullptr;

  // FIXME: Crashing on var declaration after fn declaration
  std::for_each(statements.begin(), statements.end(),
                [&](NStatement *stmt) { last = stmt->codeGen(context); });

  return last;
}

llvm::Value *NDouble::codeGen(CodeGenContext &context) {
  std::cout << "Generating code for double: " << value << std::endl;
  // Communicates context with generated bytecode
  return llvm::ConstantFP::get(*context.TheContext, llvm::APFloat(this->value));
}

llvm::Value *NInteger::codeGen(CodeGenContext &context) {
  std::cout << "Generating code for Integer: " << value << std::endl;
  return llvm::ConstantInt::get(llvm::Type::getInt64Ty(*context.TheContext),
                                value, true);
}

llvm::Value *NExpressionStatement::codeGen(CodeGenContext &context) {
  return expression.codeGen(context);
}

// Variable expression
llvm::Value *NIdentifier::codeGen(CodeGenContext &context) {
  AllocaInst *V = context.blocks.top()->locals[name];

  if (!V) {
    LogErrorV("Local not found!");
    return nullptr;
  }

  // Load variable from the stack
  return context.Builder->CreateLoad(V->getAllocatedType(), V, name.c_str());
}

llvm::Type *NIdentifier::getType(CodeGenContext &context) const {
  // TODO: Complement types?

  std::unordered_map<std::string, llvm::Type *> typeMap{
      {"int", llvm::Type::getInt64Ty(*context.TheContext)},
      {"double", llvm::Type::getDoubleTy(*context.TheContext)},
      {"float", llvm::Type::getFloatTy(*context.TheContext)},
      {"void", llvm::Type::getVoidTy(*context.TheContext)}
      //{"bool", llvm::Type::getInt64Ty(*context.TheContext)},
      //{"int", llvm::Type::getInt64Ty(*context.TheContext)},
  };

  auto it = typeMap.find(name);
  if (it == typeMap.end()) {
    // Throw Error: Unknown type

    std::string err = "Unknown type: " + name;
    LogErrorV(err.c_str());
    throw std::runtime_error(err);
  }

  return it->second;
}

llvm::Value *NBinaryOperator::codeGen(CodeGenContext &context) {
  auto toktype = op.getType();

  switch (toktype) {
  case OPERATOR_PLUS:
    std::cout << "Creating addition :" << std::endl;
    return context.Builder->CreateAdd(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempadd");
  case OPERATOR_MINUS:
    std::cout << "Creating subtraction :" << std::endl;
    return context.Builder->CreateSub(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempsub");

  case OPERATOR_DIVIDE:
    std::cout << "Creating division :" << std::endl;
    return context.Builder->CreateSDiv(lhs.codeGen(context),
                                       rhs.codeGen(context), "tempdiv");

  case OPERATOR_MULTIPLY:
    std::cout << "Creating multiplication :" << std::endl;
    return context.Builder->CreateMul(lhs.codeGen(context),
                                      rhs.codeGen(context), "tempmul");

  default:
    LogErrorV("Invalid binary op");
  }

  return nullptr;
}

llvm::Value *NVariableDeclaration::codeGen(CodeGenContext &context) {
  // Function *parentFunction = context.Builder->GetInsertBlock()->getParent();

  Function *parentFunction = context.blocks.top()->blockWrapper->getParent();

  if (context.Builder->GetInsertBlock() == nullptr) {

    //std::cout << "FN has no insertBLock" << std::endl;
    // Insert at the beginning of the function
    context.Builder->SetInsertPoint(&parentFunction->getEntryBlock());

  } else if (context.Builder->GetInsertBlock()->getParent() == nullptr) { 
    // NOTE: Unsure about this logic path might not be necessary...
    std::cout << "FN has no parent" << std::endl;
    return nullptr;
  }

  AllocaInst *alloc = nullptr;

  //    auto locals = context.blocks.top()->locals;

  auto find = context.blocks.top()->locals.find(id->name);

  Type* varType = this->type.getType(context);

    if( varType->isVoidTy())
    {
      std::string err = "invalid Data type for variables " + this->id->name;
      LogErrorV(err.c_str());
      throw std::runtime_error(err);
    }

  assert(varType);
  if (find == context.blocks.top()->locals.end()) {
    alloc = context.insertMemOnFnBlock(parentFunction, id->name,varType);

    context.blocks.top()->locals[id->name] = alloc;
    // std::cout << "Creating variable declaration: " << id->name << std::endl;
  } else {
    // Variable redefinition in the same scope detected, prevent allocation

    LogErrorV("Variable redefinition detected\n");
    throw std::runtime_error("Redefinition detected");
  }

  // NOTE: the llvm docs mention about storing the old local bindings to be able
  // to use recursion(Might need to do that later).

  Value *assignedVal = nullptr;
  if (!assignmentExpr) {
    // Initialize empty val to null
    assignedVal = Constant::getNullValue(varType);
  } else
    assignedVal = assignmentExpr->codeGen(context);

  assignedVal->print(llvm::outs(), false);
  std::cout << std::endl;

  return context.Builder->CreateStore(assignedVal, alloc);
}

llvm::Value *NAssignment::codeGen(CodeGenContext &context) {
  Value *value = rhs.codeGen(context);

  if (value == nullptr) {
    return nullptr;
  }

  // see variable existance
  Value *var = context.blocks.top()->locals[lhs.name];
  if (!var) {
    LogErrorV("Unknown variable name");
    throw std::runtime_error("Unknown variable name");
  }

  // Prevent void assignment
  if (value->getType()->isVoidTy()) {
    LogErrorV("Cannot tie void value to expression");
    throw std::runtime_error("Cannot tie void value to expression");
  }

  // load variable
  return context.Builder->CreateStore(value, var);
}

llvm::Value *NFnDeclaration::codeGen(CodeGenContext &context) {
  // FIXME: FN redefinition is not being detected

  // Prototype generation:
  auto find = context.blocks.top()->locals.find(id.name);

  // Fn redefinition or variable with same name found
  if (find != context.blocks.top()->locals.end()) {

    std::string err = "Alias redefinition detected";
    LogErrorV(err.c_str());
    throw std::runtime_error(err);
  }

  std::vector<Type *> argTypes;
  std::for_each(params.begin(), params.end(),
                [&](NVariableDeclaration *var_decl) {
                  argTypes.push_back(var_decl->type.getType(context));

                  if(var_decl->type.getType(context)->isVoidTy()){
                    std::string err = "Invalid data type for function parameter " + var_decl->id->name;
                    LogErrorV(err.c_str());
                    throw std::runtime_error(err);
                  }

                });

  Type *fnRetType = this->retType.getType(context);

  if (!fnRetType) {

    std::string err = "Unknown fn return type";
    LogErrorV(err.c_str());
    throw std::runtime_error(err);
  }

  llvm::FunctionType *FT = FunctionType::get(fnRetType, argTypes, false);

  Function *fn = Function::Create(FT, GlobalValue::InternalLinkage, id.name,
                                  context.TheModule.get());
  assert(fn);

  // Assign name args(not necessary tho)
  size_t i = 0;
  for (auto &arg : fn->args()) {
    arg.setName(params[i++]->id->name);
    // std::cout << static_cast<std::string>(arg.getName()) << std::endl;
  }

  // Function was defined
  if (fnBlock) {
    BasicBlock *BB =
        BasicBlock::Create(*context.TheContext.get(), "entry",
                           fn); // Could also insert block on curr fn?
    context.pushBlock(BB);
    // auto &nblockLocals = context.blocks.top()->locals;

    // Alloc each arg as variable in current block
    // FIXME: Not sure if I shall do the usual check to see if the var was
    // already allocated In current blocka && Var allocation below could be
    // potentially separated in a function

    context.Builder->SetInsertPoint(BB);

    for (const auto &e : params) {
      AllocaInst *alloc =
          context.insertMemOnFnBlock(fn, e->id->name, e->type.getType(context));
      context.blocks.top()->locals[e->id->name] = alloc;

      Value *nullVal = Constant::getNullValue(e->type.getType(context));
      assert(nullVal != nullptr && alloc != nullptr);

      context.Builder->CreateStore(nullVal, alloc, false);
    }

      Value *retVal = fnBlock->codeGen(context);  
        // context.Builder->CreateRet(RetVal);

        context.blocks.top()->return_value = retVal;

        // ReturnInst::Create(*context.TheContext, retVal, BB);

        // Checking if fn contains a return instance

    bool hasReturnInst = false;
    for (auto &I : *BB) {
      if (llvm::isa<llvm::ReturnInst>(&I)) {
        hasReturnInst = true;
        break;
      }
    }

        if (!hasReturnInst && fn->getReturnType()->isVoidTy()){
          std::string err =
              "Function " + this->id.name + " should have a return value";
          LogErrorV(err.c_str());
          throw std::runtime_error(err);
        }
        // Validate the generated code, This is an llvm built-in checker.
        verifyFunction(*fn);
        // std::cout << "Generated function !\n";

        // fn->removeFromParent();
        context.popBlock();

        auto pBlock = context.blocks.top()->blockWrapper;
        // Reset the insert point so instructions are emitted back in previous
        // block
        context.Builder->SetInsertPoint(pBlock);
           
  }

  context.globals[this->id.name] =
      fnInfo{fn, this->retType.getType(context), fn->getFunctionType()};
  fn->print(llvm::errs());
  return fn;
}

llvm::Value *NUnaryOperator::codeGen(CodeGenContext &context) {
  return nullptr;
}

// Doubtful bout this
llvm::Value *NReturnStatement::codeGen(CodeGenContext &context) {
  if(!this->expression){ //Void return

    //Check if the function is NOT void considering you can't return nothing from a non void function
if(!context.blocks.top()->blockWrapper->getParent()->getReturnType()->isVoidTy()){
      std::string err = "Function " + context.blocks.top()->blockWrapper->getName().str() + " should return a value";
      LogErrorV(err.c_str());
      throw std::runtime_error(err);
    }
    ReturnInst::Create(*context.TheContext, context.blocks.top()->blockWrapper);
    return nullptr;
  }
  Value *retVal = expression->codeGen(context);

  //Insert instruction in the current block
  ReturnInst::Create(*context.TheContext, retVal, context.blocks.top()->blockWrapper);

  if (!retVal) {
    std::string_view err = "Return statement codegen failed";
    LogErrorV(err.data());
    throw std::runtime_error(err.data());
  }

  retVal->print(llvm::outs(), false);
  std::cout << std::endl;
  return retVal;
}

llvm::Value *NFnCall::codeGen(CodeGenContext &context) {
  // 1. Make sure fn is defined within globals
  // 2. make sure fn is callable(is not a variable) TODO:
  // 3. Check if it has a block within it. TODO:
  // 4. Get expression(s) from ast

  // Get relevant info to call the function
  auto find = context.globals.find(this->id.name);

  // Check if Fn was defined
  const Function *fn = context.TheModule->getFunction(id.name);

  if (fn) {
    std::vector<Value *> args;
    if (arguments.size() == fn->arg_size()) {
      unsigned i = 0;
      for (auto &arg : this->arguments) {
        Value *V = arg->codeGen(context);
        Type *paramType = find->second.fnType->getParamType(i);
        Value *bitcastedArg =
            context.Builder->CreateBitCast(V, paramType); // thanks bolt!
        args.push_back(bitcastedArg);
        i++;
      }
    } else {
      std::string err =
          "Argument size mismatch in Function: " + this->id.name + "\n";
      LogErrorV(err.c_str());
      throw std::runtime_error(err);
    }

    // auto valCall = context.Builder->CreateCall(
    //     ffind, args);

    // assert(find->first == ffind->getName());

    auto valCall = context.Builder->CreateCall(
        find->second.fnType, find->second.fn, args, find->first);

    return valCall;
  } else {

    std::string err = "Function " + this->id.name + " not found";
    LogErrorV(err.c_str());
    throw std::runtime_error(err);
  }
}

llvm::Value *NWhileStatement::codeGen(CodeGenContext &context) {
  return nullptr;
}

llvm::Value *NForStatement::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NString::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NIfStatement::codeGen(CodeGenContext &context) { return nullptr; }

llvm::Value *NElseStatement::codeGen(CodeGenContext &context) {
  return nullptr;
}
